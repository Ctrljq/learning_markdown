# M matree

## 题目大意：

给定一个 n 个节点的树，每个节点都有权值 *ai* 和父节点 *pi*​

q 次询问两个相同深度的节点 *x* , *y* ,求 𝑓(𝑥,𝑦)。
$$
f(x, y)=\left\{\begin{array}{ll}
0 & (x=y=0) \\
f\left(p_{x}, p_{y}\right)+a_{x} \cdot a_{y} & (x, y \neq 0)
\end{array}\right.
$$

### 题解：

TAG: 根号分治

首先考虑暴力的做法，记忆化搜索，直接记录所有同深度节点的 𝑓(𝑥,𝑦)，但是空间不够

思考:需要记录所有节点吗 ? 假设每一层有 *x* 个节点

- 对于节点数 > $\sqrt{n}$ 的层，这样的层小于 $\sqrt{n}$ 个，每一层被调用时暴力向上跳，最大处理次数为 $q*\sqrt{n}$
- 对于节点数 < $\sqrt{n}$ 的层，被调用时直接返回记忆化搜索的值，最坏需要记录 $x^2$ 次，所以最大处理次数为$x^2*\frac{n}{x}=n*x$
- 综上时间复杂度为$O(x*\sqrt{x}+q*\sqrt{n})$

注意题意：需要跳到根节点而不是lca节点

# N 香味鸡丝

## 题目大意：

现给出一棵 *n* 个节点的有根树，标号为 1 ~ *n*，维护以下三种操作：

- ① 换根
- ② LCA+子树修改
- ③ 子树查询

### 题解：

TAG: 树链剖分

本题的重点在于换根，如果没有换根操作，那么我们只需要对这棵树的 DFS 序建立线段树，支持区间修改和区间查询。

如果考虑换根，显然不能真的把根换掉，而是要对根和操作的节点的关系进行分类讨论！

首先思考换根对子树操作产生的影响，设当前点为x：

- lca(x,root) != x 时，换根不影响当前子树操作
- lca(x,root) = x 时，相当于操作所有节点除去以 x 到 root 的路径上的第一个节点为根的子树。那么我们可以根据容斥原理，先对整棵树进行操作，再对那个子树进行相反的操作
- x=root，相当于整个树操作（操作原根节点1）

然后思考换根对lca产生的影响：

- 如果 *x* , *y* 都在 root 的子树内，那么lca(x,y) 显然不变
- 如果 *x* , *y* 只有一个在 root 的子树内，那么lca(x,y)=root
- 如果 *x* , *y* 都不在 root 的子树内，设 p=lca(x,root), q=lca(y,root)。p,q其中较深的一个就是换根后的lca（深度相同时为同一个点，可以自己画图验证一下）

# P 光棱塔

## 题目大意：

n座光棱塔，编号从1到n，第i座光棱塔属于链接$si$.
规定同一链接下光棱塔的战力总和$f(si)= si * h(si)^2$，$ h(si)$ 为链接$si$中光棱塔数。

m次独立询问移除区间$[ai,bi]$后，所有链接内战力总和

### 题解：

TAG: 莫队

这题最简单做法无非暴力——记录每个数值出现的次数和初始答案，再暴力枚举l到r减去统计次数，输出答案即可。然而实在跑不起。

由于是离线输出，所以用莫队剪下枝

理想的询问排序后呈现$[1,n]$$[1,n-1]$$[1,n-2]$......$[1,2]$$[2,2]$$[2,3]$......$[2,n]$,每次区间移动距离尽可能小。

由于左边界不可能完全重复，我们可以按每$\sqrt{n}$的距离来分块

对于左指针：每次左区间移动最大次数为$\sqrt{n}$，最坏只需总共$n*\sqrt{n}$跳，总复杂度$O(n\sqrt{n})$；

对于右指针：设每个块 i 中分布有 xi个左端点，由于左端点同块的区间右端点有序，那么对于这xi个区间，右端点最坏只需总共$O(n)$的时间，总复杂度$O(n\sqrt{n})$。

# R  尽力局

## 题目大意：

有 $ n $ 个元素，第 $ i $ 个元素有 $ a_i,b_i,c_i $ 三个属性，设 $ f(i) $ 表示满足 $ a_j \leq a_i $ 且 $ b_j \leq b_i $ 且 $ c_j \leq c_i $ 且 $ j \ne i $ 的 $j$ 的数量。

对于 $ d \in [0, n) $，求 $ f(i) = d $ 的数量。

### 题解：

TAG: CDQ分治

首先按*a*为第一关键字，*b*为第二关键字，*c*为第三关键字排序，保证第一维有序。

这样我们只需要考虑两维的情况。于是使用分治，将某一个序列$[l,r]$,分成段$[𝑙,𝑚𝑖𝑑]$和$[𝑚𝑖𝑑+1,𝑟]$,然后在对$[𝑙,𝑟]$​这段区间的第二维进行排序。这样一来我们得到的两个序列拥有以下的性质：

​	1.左序列的任意x值都小于右序列的任意x值

​	2.每一个序列里的y值都是单调递增的

最后我们分别在序列头和序列中点设定两个指针j和i，对于每一个i，j都从上一个不满足条件的地方开始枚举，将j对应的y小于i对应的y的j加入树状数组中，最后只要判断z值是否满足条件就可以了。（若点在排序前属于$[𝑙,𝑚𝑖𝑑]$,树状数组单点修改；否则该点在排序前属于$[𝑚+1,𝑟]$,统计一次）。

时间复杂度，$𝑇(𝑛)=O(n*logn*logk)$。