# 一、基本概念

「分治 divide and conquer」，全称分而治之，是一种非常重要且常见的算法策略。**分治通常基于递归实现，**包括“分”和“治”两个步骤。

1. **分（划分阶段）** ：递归地将原问题分解为两个或多个子问题，直至到达最小子问题时终止。
2. **治（合并阶段）** ：从已知解的最小子问题开始，从底至顶地将子问题的解进行合并，从而构建出原问题的解。![img](https://img-blog.csdnimg.cn/direct/0238f47fdced47d9b6ac7bfbc9a15ddf.png)

## **1.如何判断分治问题**

一个问题是否适合使用分治解决，通常可以参考以下几个判断依据。

1. **问题可以被分解** ：原问题可以被分解成规模更小、类似的子问题，以及能够以相同方式递归地进行划分。
2. **子问题是独立的** ：子问题之间是没有重叠的，互相没有依赖，可以被独立解决。
3. **子问题的解可以被合并** ：原问题的解通过合并子问题的解得来。

显然，归并排序是满足以上三条判断依据的。

1. **问题可以被分解** ：递归地将数组（原问题）划分为两个子数组（子问题）。
2. **子问题是独立的** ：每个子数组都可以独立地进行排序（子问题可以独立进行求解）。
3. **子问题的解可以被合并** ：两个有序子数组（子问题的解）可以被合并为一个有序数组（原问题的解）。

## **2. 通过分治提升效率**

**为什么分治可以提升算法效率，其底层逻辑是什么** ？换句话说，将大问题分解为多个子问题、解决子问题、将子问题的解合并为原问题的解，这几步的效率为什么比直接解决原问题的效率更高？ 

# 二、`CDQ`分治

## 1、基本概念

CDQ分治大致有两个基本形式：**多维偏序降维** 和 **动态修改转换成静态修改统一查询**。只要问题能转化成这两个形式，那就可以考虑用CDQ分治了。

> 参照一、二维偏序的方法，会发现一位偏序就是直接排序，可以看成通过排序使第一维无效。二维偏序是排序+树状数组，就是先通过排序消除了第一维的影响，再通过树状数组进行统计。那么以此类推，三位偏序应该就是树套树状数组…啊不对，是**先通过排序消除第一维的影响，再通过【某种方法】消除第二维的影响，再用树状数组统计。**
>
> 传说中的【某种方法】就是cdq分治，它是一种通过计算前一半对后一半的影响的降维手段。
>
> 具体来说，**假设三维分别是x,y,z，先按x排序。分治时每次将前半边、后半边分别按y排序。虽然现在x的顺序被打乱了，但是前半边还是都小于后半边的，所以要是只计算前半边对后半边的偏序关系，是不会受到x的影响的。维护后一半的指针i，前一半的指针j，每次将i后移一位时，若y[j]<=y[i]则不断后移j，并不断将z[j]加入树状数组。然后再查询树状数组中有多少数小于等于z[i]。 最后要清空树状数组。**
>
> 还有“**偏序问题中出现了完全相同的要把它们合并**”、“**清空树状数组时要减回去否则时间超限**”、“**前大括号必须放在下面**“这些细节在此就不提了。
>
> 然后就会发现，一维偏序也可以cdq（虽然大部分人叫它归并排序）、树状数组做，二维偏序也可以cdq做。也就是说，这些降维手段用在第几维都可以。那么会不会有n维偏序，cdq套cdq什么的呢？据说那样复杂度就会在$nlog^kn$，还不如$n^2$暴力枚举。
>
>  其实 cdq 应该不会只局限于偏序问题，也许会有整体二分之类的离线方法是参照cdq的算出前一半对后一半的影响这种思想呢？

- 分。递归处理左边区间[L,M]和右边区间[M+1,R]的问题。
- 治。合并两个子问题，同时考虑到[L,M]内的修改对[M+1,R]内的查询产生的影响。即，用左边的子问题帮助解决右边的子问题。
  　　
