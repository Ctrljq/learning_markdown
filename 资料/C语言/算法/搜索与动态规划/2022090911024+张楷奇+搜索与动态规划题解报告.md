[TOC]



# F、激流勇进

**要寻找起点，终点都不可扩展的满足公差为h的等差路径有多少条（==不包含水深为0的路径==）。**

> ​	解题思路:
>
> ​	我们可以在用邻接矩阵存图后，遍历整个图，用一个in，ot数组记录每个节点的入度与出度大小从而方便识别出哪些可以作为不可扩展的起点，哪些可以作为不可扩展的终点。因为vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};并同时用vector<int>记录下每个点出度可以指向哪个点（记录为0,1,2,3分别对应着directions四个元素 ）。
>
> ​	再引入一个队列q，用类似拓扑排序的方式处理每个节点，入度为0则入队。
>
> ​	`long long f[1000][1000][10];     //f[i][j][x]：坐标（i，j）的点，路线长为x的长度【x=0表示长为1】`作为DP数组。入度为0的且有水深的节点初始化为1；`f[i][j][0]=1`；
>
> 状态转移方程：
>
> ```cpp
> queue<pair<int,int>> q;
> auto temp=q.front();
> ```
>
> ```cpp
> for(int cnt=1;cnt<k;++cnt){
>     f[x][y][cnt]=(f[x][y][cnt]+f[temp.first][temp.second][cnt-1])%MOD;
> }
> f[x][y][k-1]=(f[x][y][k-1]+f[temp.first][temp.second][k-1])%MOD;
> ```

# G、集合的并

**找至少需要多少个集合才能构成全集**

> 解题思路：
>
> 考虑到数据规模小。集合最多15个元素，所以用二进制1~1<<15来代表是否被选中。
>
> int f[100] [1<<15];作为DP数组，表示前i个集合，能够构成j的最少情况数。
>
> int Set[100];表示每个集合对应的二进制数。
>
> 状态转移方程：
>
> ```cpp
> int cnt=1<<m;
> for(int i=1;i<n;++i){
>     for(int j=1;j<cnt;++j){
>         f[i][j|Set[i]]=min(f[i][j|Set[i]],f[i-1][j]+1);
>         f[i][j]=min(f[i][j],f[i-1][j]);
>     }
> }
> ```

# I、饮食计划

**n为背包容量，m为物品种类，每一种物品有nums[i]个。求有多少种不同方案装满背包**

> # 解题思路：
>
> ## 优化空间：   
>
> DP数组按常规思路直接初始化long long f[100000] [100000]会超内存，因为每次更新都只用上一行的数据，所以考虑用两个一维数组优化，每行执行完后f.swap(g);
>
> ## 优化时间：
>
> 按常规多重背包类似思路，时间复杂度为`O（nm∑（nums））`，考虑使用前缀和进行优化。引入一个pre_num一维数据。

# W、围棋

**在摆有黑白棋子的5×5棋盘上，找大小为7的且白棋子多于黑棋子的连通块的个数**

> 解题思路：
>
> 考虑暴力搜索。用递归找出25选7的所有可能情况，也可以选择提前生成的所有可能情况存储起来，再一个一个遍历。然后对每一种可能情况，选择一个起始点使用BFS搜索该节点连通节点数是不是等于7。
>
> ```cpp
> if(board[x][y]=='J'){
>     search(index+1,current,h_count,j_count+1);
> } 
> else{
>     search(index+1,current,h_count+1,j_count);
> }
> ```
>
> 在搜索组合情况时，参数中便记录下黑白棋子各自个数，后续不必再统计。

# X、叠梯子

**找出梯子组合后减h的差值最小的情况（差值大于等于0）**

> 解题思路：
>
> 暴力枚举即可。最多20个梯子，数据规模也不大。用二进制数表示，0表示没选，1表示选了。一共1<<n种情况。一个一个算，得出最小答案。



# Y、 虾头卷狗莫得情感 · 其二

**给定密码长度和密码每一位范围，求满足各位之和为4的整数倍数的密码有多少种。**

> 解题思路：
>
> 密码长度为L。AB为密码范围。先预处理出密码范围内， 模4余0、1、2、3的数量。记录为abcd
>
> DP数组：f[i] [j]  表示长度为 i，余数为 j 时的数量。
>
> 状态转移方程：$f[i][j]=∑_{k=0}^3(a_k ×  f [i − 1] [( j−k+4) \mod4 ])$。$a_k$分别对应abcd
>
> 观察发现，后续的计算都是有规律的。对每一行的处理，可以看作是与右乘特定矩阵后的结果。
>
> ```cpp
> matrix={  
>     {
>          {a,b,c,d},
>          {d,a,b,c},
>          {c,d,a,b},
>          {b,c,d,a}
>         }
> };
> ```
>
> 对于该特定矩阵使用矩阵快速幂算法简化计算步骤。