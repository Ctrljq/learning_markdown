# 壹、二分图的匹配问题

**匹配的两个重点：1. 匹配是边的集合；2. 在该集合中，任意两条边不能有共同的顶点**。

**匹配**是**由一组没有公共端点的不是圈的边构成的集合**。

## 1、匹配的类型

 **最大匹配**
选择这样的边数最大的子集称为图的最大匹配问题。最大匹配的边数称为最大匹配。

**完美匹配**
如果一个匹配中，图中的每个顶点都和图中某条边相关联，则称此匹配为完美匹配（完全匹配），也称作完备匹配。
考虑部集为X={x1 ,x2, …}和Y={y1, y2, …}的二分图，一个完美匹配就是定义从X-Y的一个双射，依次为x1, x2, … xn找到配对的顶点，最后能够得到 n！个完美匹配。

**最优匹配**
最优匹配又称为带权最大匹配，是指在带有权值边的二分图中，***求一个匹配使得匹配边上的权值和最大***。
一般X和Y集合顶点个数相同，最优匹配也是一个完备匹配，即每个顶点都被匹配。如果个数不相等，可以通过补点加0边实现转化。一般使用KM算法解决该问题。

**最小覆盖**
二分图的最小覆盖分为最小顶点覆盖和最小路径覆盖：①最小顶点覆盖是指最少的顶点数使得二分图G中的每条边都至少与其中一个点相关联，**二分图的最小顶点覆盖数=二分图的最大匹配数**；②最小路径覆盖也称为最小边覆盖，是指用尽量少的不相交简单路径覆盖二分图中的所有顶点。二分图的最小路径覆盖数=|V|-二分图的最大匹配数；

**最大独立集**
最大独立集是指寻找一个点集，使得其中任意两点在图中无对应边。对于一般图来说，最大独立集是一个NP完全问题，对于二分图来说：最大独立集=|V|-二分图的最大匹配数。

**交替路**
从未匹配点出发，依次经过未匹配的边和已匹配的边，即为交替路，如Fig.3：3 -> 5 -> 1 -> 7 -> 4 -> 8

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200919152447831.png#pic_center)

**增广路（也称增广轨或交错轨）**
如果交替路经过除出发点外的另一个未匹配点，则这条交替路称为增广路，如交替路概念的例子，其途径点8，即为增广路。

由增广路的定义推出下面三个结论（设P为一条增广路）：
1). P的路径长度一定为奇数，第一条边和最后一条边都是未匹配的边（根据要途经已匹配的边和要经过另一个未匹配点，这个结论可以理解成第一个点和最后一个点都是未匹配点，可以在Fig.3上的增广路观察到）

2).对增广路径编号，所有奇数的边都不在M中，偶数边在M中。

3). P经过取反操作可以得到一个更大的匹配图，比原来匹配多一个（取反操作即，未匹配的边变成匹配的边，匹配的边变成未匹配的边，这个结论根据结论1).和交替路概念可得该结论）

4). 当且仅当不存在关于图M的增广路径，则图M为最大匹配。所以匈牙利算法的思路就是：不停找增广路，并增加匹配的个数。

# 二、匈牙利算法

```cpp
// Luogu P3386 【模板】二分图最大匹配
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N=505,M=100010;
int n,m,k,a,b,ans;
struct edge{int v,ne;}e[M];
int h[N],idx;
int vis[N],match[N];

void add(int a,int b){
  e[++idx]={b,h[a]};
  h[a]=idx;
}
bool dfs(int u){
  for(int i=h[u];i;i=e[i].ne){
    int v=e[i].v; //妹子
    if(vis[v]) continue;
    vis[v]=1; //先标记这个妹子
    if(!match[v]||dfs(match[v])){
      match[v]=u; //配成对
      return 1;
    }
  }
  return 0;
}
int main(){
  cin>>n>>m>>k;
  for(int i=0;i<k;i++)
    cin>>a>>b, add(a,b);
  for(int i=1;i<=n;i++){
    memset(vis,0,sizeof vis);
    if(dfs(i)) ans++;
  }
  cout<<ans;
  return 0;
}
```

