## patch_embeding

```
PatchEmbed(
  (proj): Conv2d(3, 96, kernel_size=(4, 4), stride=(4, 4))
  (norm): LayerNorm((96,), eps=1e-05, elementwise_affine=True)
)
```

```py
print(x.shape)  # torch.Size([4, 3, 224, 224])  4 是batch size, 3 是通道数，224是图片的大小
x = self.patch_embed(x)
print(x.shape)  # torch.Size([4, 3136, 96])
```

## 代码语法解读

```py
x = (attn @ v).transpose(1, 2).reshape(B_, N, C)
# x为torch.Size([256, 49, 96])
# attn为torch.Size([256, 3, 49, 49])
# v为torch.Size([256, 3, 49, 32])
```

> 我们可以逐步解析这行代码及其相关张量的维度变化：
>
> ```python
> x = (attn @ v).transpose(1, 2).reshape(B_, N, C)
> ```
>
> ### 1. `attn @ v`
>
> 首先，我们要理解 `attn @ v` 的计算。`@` 运算符是矩阵乘法（也可以理解为张量乘法）。
>
> - `attn` 的形状是 `(256, 3, 49, 49)`，其中：
>   - `256` 是批次大小（batch size，`B_`）。
>   - `3` 是 attention heads 的数量（`num_heads`）。
>   - `49` 是查询（query）和键（key）的长度（`N`）。
>   - `49` 是值（value）的长度（`N`）。
> - `v` 的形状是 `(256, 3, 49, 32)`，其中：
>   - `256` 是批次大小（batch size，`B_`）。
>   - `3` 是 attention heads 的数量（`num_heads`）。
>   - `49` 是值向量的长度（`N`）。
>   - `32` 是值向量的维度（`C_v`，即每个值向量的特征维度）。
>
> ### 计算过程
>
> `attn @ v` 进行的是批次和头维度下的矩阵乘法，具体如下：
>
> - `attn` 的形状是 `(B_, heads, N, N)`，其中 `N` 是查询和键的长度。
> - `v` 的形状是 `(B_, heads, N, C_v)`，其中 `N` 是值向量的长度，`C_v` 是值向量的特征维度。
>
> ==矩阵乘法是基于 `attn` 的最后一个维度 `N` 和 `v` 的倒数第二个维度 `N`（这两个维度必须相同）。结果将是一个新的张量，形状是 `(B_, heads, N, C_v)`==，即：
>
> - `attn @ v` 的形状为 `(256, 3, 49, 32)`。
>
> ### 2. `transpose(1, 2)`
>
> 接下来，我们对张量进行转置操作。`transpose(1, 2)` 是交换第二维和第三维，即：
>
> - 原来的形状是 `(B_, heads, N, C_v)`，即 `(256, 3, 49, 32)`。
> - `transpose(1, 2)` 后，新的形状将是 `(256, 49, 3, 32)`。
>
> ### 3. `reshape(B_, N, C)`
>
> 最后，执行 `reshape(B_, N, C)` 操作，重新调整张量的形状。为了使得形状符合 `(B_, N, C)`，我们需要根据具体情况决定如何调整维度。在这里，假设 `C` 是 `3 * 32`，即 `C = 96`，那么我们将 `49 * 3 * 32` 展开为一个新的形状 `(B_, N, C)`，其中：
>
> - `B_` 是批次大小，`256`。
> - `N` 是 `49`（查询的长度）。
> - `C` 是 `96`（合并了 `3` 个 attention heads 和每个值向量的 `32` 维度）。
>
> 最终，`x` 的形状将是 `(256, 49, 96)`。
>
> ### 总结
>
> - `attn @ v` 的计算结果是 `(256, 3, 49, 32)`。
> - `transpose(1, 2)` 将形状转置为 `(256, 49, 3, 32)`。
> - `reshape(B_, N, C)` 将形状调整为 `(256, 49, 96)`，其中 `C = 3 * 32 = 96`。
>
> 所以，最终 `x` 的形状是 `(256, 49, 96)`。