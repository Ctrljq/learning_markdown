# 一、卡尔曼滤波

![深入浅出理解卡尔曼滤波【实例、公式、代码和图】](https://picx.zhimg.com/70/v2-e6cf1159a7971f47262368e695378ea7_1440w.image?source=172ae18b&biz_tag=Post)

[深入浅出理解卡尔曼滤波【实例、公式、代码和图】 - 知乎](https://zhuanlan.zhihu.com/p/649997859)

<img src="C:/Users/HUAWEI/AppData/Roaming/Typora/typora-user-images/image-20241122105122132.png" alt="image-20241122105122132" style="zoom:67%;" />

## 1、（线性）卡尔曼滤波的应用基于以下三个假设前提

1. 当前时刻状态只和**上一时刻**状态有关。
2. 模型和系统均满足**线性**关系。
3. 引入的噪声符合**高斯**分布。

> 卡尔曼滤波的三个基本假设在实际应用中并不总是满足，以下是违反每个假设的具体情况及举例：
>
> | 假设                             | 不满足情况                                               | 示例                                                         |
> | -------------------------------- | -------------------------------------------------------- | ------------------------------------------------------------ |
> | 当前时刻状态只和上一时刻状态有关 | **状态依赖于更早的历史状态**，而不是仅仅与上一时刻有关。 | **股票市场预测**：股价可能受到长期趋势和多个过去时刻价格的综合影响，而不仅仅是上一时刻。 |
> | 模型和系统满足线性关系           | **系统是非线性的**，状态变化受复杂非线性关系影响。       | **机器人控制**：机器人在复杂地形中行走时，其速度和位置的变化可能受到非线性动力学影响。 |
> | 噪声符合高斯分布                 | **噪声分布非高斯**，可能呈现偏态、峰态或含有突发噪声。   | **雷达目标跟踪**：雷达回波信号可能包含大量的非高斯干扰，如多路径反射或短时强噪声。 |
>
> ### 进一步解释
>
> #### 1. **状态依赖性问题**
>
> - **情况**：系统具有长时记忆性。
> - **解决方案**：引入**扩展状态空间模型**或**粒子滤波**，将历史信息融入状态估计。
>
> #### 2. **非线性问题**
>
> - **情况**：例如物体在高加速度下运动时，状态的预测和更新方程可能呈现非线性。
> - **解决方案**：使用**扩展卡尔曼滤波（EKF）\**或\**无迹卡尔曼滤波（UKF）**，通过线性化处理或使用采样点近似非线性。
>
> #### 3. **非高斯噪声问题**
>
> - **情况**：信号中噪声来源复杂或具有突发性强干扰。
> - **解决方案**：使用**鲁棒滤波**，例如**粒子滤波（PF）**，无需对噪声分布假设过强限制。
>
> ### 实际工作应用
>
> - **自动驾驶**：在非线性运动和复杂噪声干扰下，需要结合EKF或UKF处理车辆定位和障碍物检测。
> - **金融市场建模**：面对非高斯分布的市场波动时，需引入粒子滤波以捕捉多模态数据特性。
> - **运动跟踪**：对非线性运动的物体（如无人机）建模时，线性假设不适用，需使用非线性滤波器。

## 2、过程模型和测量模型的公式

基于上述假设，我们可以得到如下两个表征过程模型和测量模型的公式：

$x_k=Fx_{k−1}+Bu_{k−1}+w_k …… ①$

$z_k=Hx_k+v_k …… ②$

公式①表示过程模型，公式②表示测量模型。 $F、B、H$​​ 分别表示状态转移矩阵、控制矩阵、观测转移矩阵

### 过程模型解读

> ## $x_k=Fx_{k−1}+Bu_{k−1}+w_k …… ①$
>
> ### 1. **符号解析**
>
> - $x_k$：系统的状态向量（state vector），表示当前时刻的状态，例如位置、速度等。
>
> - ==$F$：状态转移矩阵==（state transition matrix），定义了状态从$k-1$时刻到 $k$
>
>    时刻的线性关系。
>
>   - ==维度为 $n \times n$，其中 $n$ 是状态向量的维度==。
>
> - $u_{k-1}$：控制输入（control input），表示从外界施加给系统的控制量，例如驱动力、方向等。
>
> - B：控制输入矩阵（control input matrix），定义了控制输入如何影响状态变化。
>
>   - 维度为 $n \times m$，其中 m 是控制向量的维度。
>
> - ==$w_k$：过程噪声==（process noise），表示系统状态转移过程中引入的不确定性（例如环境干扰、模型误差）。
>
>   - ==通常假设 $w_k$ 服从零均值、高斯分布，协方差为 Q。==
>
> ------
>
> ### 2. **公式解释**
>
> $x_k = Fx_{k-1} + Bu_{k-1} + w_k$
>
> 这表示：
>
> 1. **状态转移部分（$Fx_{k-1}$）**：
>    - 描述状态 $x_{k-1}$如何根据状态转移矩阵 F 演变为下一时刻的状态 $x_k$。
>    - F 包含系统的动力学信息，例如物体的位置和速度如何随时间变化。
> 2. **控制输入部分（$Bu_{k-1}$）**：
>    - 表示外界施加的控制量 $u_{k-1}$ 对状态变化的影响。
>    - 例如，车辆的速度由加速度（控制输入）决定，矩阵  B 描述了加速度对速度的影响程度。
> 3. **过程噪声部分（$w_k$）**：
>    - 表示系统状态转移中的不确定性，包括建模误差和随机环境影响。
>    - $w_k$​ 引入了随机性，使得状态转移方程更加贴近实际。
>
> <img src="C:/Users/HUAWEI/AppData/Roaming/Typora/typora-user-images/image-20241122150820428.png" alt="image-20241122150820428" style="zoom:80%;" />

### 测量模型解读

> ## $z_k=Hx_k+v_k …… ②$
>
> ​	$z_k$ 表示 k 时刻的**观测值**，例如雷达或者GPS测量结果，它可能和 $x_k$ 保持相同维度，也可能和 $x_k$ 不同维度，比如 $x_k$ 包括位置和速度，但测量仪器只观测位置信息，而忽略了速度信息；又例如，视觉里程计中，直接观测结果是图像像素，而状态量是位姿信息。
>
> $z_k$：==观测值（measurement vector），是传感器测量到的实际数据，例如雷达测量的位置、GPS信号等==。
>
> - 维度可能小于、等于或大于状态向量$x_k$。
>
> $x_k$：==系统的状态量（state vector），是系统描述的真实状态，比如位置、速度等==。
>
> ==$H$：观测矩阵（observation matrix），定义了观测值 $z_k$ 和状态量 $x_k$ 的线性关系。==
>
> - 矩阵 $H$ 的维度为 $m \times n$，其中 $m$ 是观测值的维度，$n$ 是状态向量的维度。
>
> $v_k$​：观测噪声（observation noise），表示传感器测量误差，通常假设为服从零均值、高斯分布的随机变量。



### 观测矩阵H

> ==卡尔曼滤波中的 H 矩阵（观测矩阵）取决于传感器或设备提供的测量数据与系统状态之间的关系。==
>
> 在 **DeepSORT** 中的目标跟踪，**ReID（Re-Identification）** 模块提供的特征信息不直接与目标的物理状态（例如位置和速度）相关，而是通过目标的外观特征进行匹配。以下是 H 矩阵的分析：
>
> ------
>
> ### 1. **DeepSORT 中的状态与观测**
>
> - **状态向量 $x_k$：** DeepSORT 中卡尔曼滤波器的状态通常包括：
>
>   $x_k = [u, v, s, r, \dot{u}, \dot{v}, \dot{s}, \dot{r}]^T$
>
>   - u,, v：目标的中心位置（像素坐标）。
>   - s：目标的面积（bounding box 面积）。
>   - r：目标的宽高比。
>   - $\dot{u}, \dot{v}, \dot{s}, \dot{r}$：上述量的变化率。
>
> - **观测向量 $z_k$：** DeepSORT 的观测数据来自于目标检测器，通常包括：
>
>   $z_k = [u, v, s, r]^T$
>
>   观测值提供了目标检测框的位置、面积和宽高比，但不包括速度等动态信息。
>
> ------
>
> ### 2. **观测矩阵 H 的形式**
>
> 观测矩阵 H 描述了观测值 $z_k$ 如何与状态向量 $x_k$ 关联。在 $DeepSORT$ 中，观测向量 $z_k$ 只包含$[u, v, s, r]$，因此 H 矩阵通常是：
>
> $H =  \begin{bmatrix} 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \end{bmatrix}$
>
> 这个矩阵的含义是：观测值 $z_k$ 与状态向量 $x_k$ 的前 4 个分量（位置、面积、宽高比）一一对应，而后 4 个分量（速度信息）并不包含在观测中。
>
> ------
>
> ### 3. **ReID 模块的作用**
>
> ReID 提供的是目标的外观特征，用于在目标检测与跟踪之间进行匹配，而不是直接参与卡尔曼滤波的观测过程。因此，ReID 的特征并不会改变 H 矩阵，而是作为额外的信息融合模块，与卡尔曼滤波的输出结果进行匹配和关联。
>
> ------
>
> ### 4. **总结**
>
> 在 DeepSORT 中：
>
> 1. H 矩阵通常是一个从完整状态向量到观测分量（如位置、面积和宽高比）的映射矩阵，表示测量设备（如目标检测器）的能力。
> 2. ReID 模块不直接影响 H 矩阵，而是通过外观特征辅助跟踪器关联目标。
> 3. 如果系统需要扩展，例如引入 ReID 提供的外观特征到滤波器中，可以考虑修改状态向量和观测矩阵，但这会增加系统复杂性。

> ### **观测矩阵 $H$** 
>
> 实际测量值 $z_k$ 是由状态向量 $x_k$ 通过观测矩阵 $H$ 线性变换得到的“理论测量值”，加上观测噪声 $v_k$。
>
> **观测矩阵 $H$** 决定了系统能够“看到”状态 $x_k$​​ 的哪些部分。
>
> | 应用场景     | 状态量 $x_k$     | 观测值 $z_k$     | 观测矩阵 $H$             |
> | ------------ | ---------------- | ---------------- | ------------------------ |
> | GPS导航      | $[x, y]$         | $[x, y]$         | 单位矩阵，直接观测。     |
> | 雷达跟踪     | $[x,y,v_x,v_y]$  | [x, y]$          | 位置观测，速度被忽略。   |
> | 视觉里程计   | $[x, y, \theta]$ | 图像像素$[u, v]$ | 位姿到像素的投影矩阵。   |
> | 多传感器融合 | 任意状态量       | 冗余观测值       | 决定了如何融合多源数据。 |
>
> 
>
> ![image-20241122145059655](C:/Users/HUAWEI/AppData/Roaming/Typora/typora-user-images/image-20241122145059655.png)

## 3、原理推导

> 对于公式②，我们借鉴上述做法，同样忽略掉测量噪声 vk ，得到
>
> ==$z_k=Hx_{k}^{measure}⇒x_{k}^{measure}=H^{−1}z_k$==
>
> 我们通过观测值和观测矩阵获得了和预估值相同维度的 $x_{k}^{measure}$，因此将其和 $x_k^−$ 作差，用来修正预估值，则有
>
> $\hat{x}_k=x_k^−+G⋅(x_{k}^{measure}−x_k^−)$
>
> 其中，G为系数矩阵。
>
> 这本质上和以下修正方式是同一种表述
>
> ==$\hat{x}_k=Ax_k^−+Bx_{k}^{measure}，A+B=I$==
>
> 此时有 $A=I−G,B=G$ 。
>
> 为进一步简化，我们不妨设 $G=K⋅H$ ，因此有
>
> $\hat{x}_k=x_k^−+G⋅(x_{k}^{measure}−x_k^−)=x_k^−+KH(H^{−1}z_k−x_k^−)$
>
> ==$\hat{x}_k=x_k^−+K(z_k−Hx_k^−)$==
>
> 其中，==K为卡尔曼增益==，当前为未知量，==$\hat{x}_k$ 为最优值，由于和当前时刻的观测量有关系，也称为**后验估计值**。==

## 4、关于协方差矩阵

$P_K$就是一个协方差矩阵

> **协方差矩阵（Covariance Matrix）** 是描述多维随机变量之间**线性相关性**和**方差信息**的矩阵。在概率统计中，它是用来刻画变量之间的关系及其分布的一个重要工具。
>
> ------
>
> ### 1. **定义**
>
> 对于一个 nn 维随机向量 $ \mathbf{X} = [X_1, X_2, \dots, X_n]^T$ ，其协方差矩阵定义为：
>
> $\mathbf{Cov}(\mathbf{X}) =  \mathbb{E} \left[ (\mathbf{X} - \mathbb{E}[\mathbf{X}]) (\mathbf{X} - \mathbb{E}[\mathbf{X}])^T \right]$
>
> ![image-20241122154917597](C:/Users/HUAWEI/AppData/Roaming/Typora/typora-user-images/image-20241122154917597.png)
>
> #### 矩阵属性：
>
> - 协方差矩阵是对称的： $\mathrm{Cov}(X_i, X_j) = \mathrm{Cov}(X_j, X_i)$。
> - 协方差矩阵的对角元素是变量的方差。
> - 协方差矩阵的非对角元素是变量之间的协方差，反映了它们的线性相关程度。
>
> ------
>
> ### 2. **几何意义**
>
> - **对角元素（方差）**：反映每个随机变量的分布范围，数值越大，变量的分布越分散。
> - 非对角元素（协方差）：
>   - **正值**：变量之间正相关，值越大，正相关性越强。
>   - **负值**：变量之间负相关，值越大（绝对值越大），负相关性越强。
>   - **接近零**：变量之间基本无关。
>
> 协方差矩阵描述了多维随机变量分布的**形状和大小**，可以看作是随机变量分布的“伸展方向”。
>
> ------
>
> ### 3. **示例：二维随机变量**
>
> 假设随机向量 $\mathbf{X} = [X_1, X_2]^T$，其协方差矩阵为：
>
> $\mathbf{Cov}(\mathbf{X}) = \begin{bmatrix} \mathrm{Var}(X_1) & \mathrm{Cov}(X_1, X_2) \\ \mathrm{Cov}(X_2, X_1) & \mathrm{Var}(X_2) \end{bmatrix}$
>
> #### 举例：
>
> - 假设 $X_1$ 是一个人的身高（单位：厘米）， $X_2$ 是体重（单位：千克）。
>
> - 数据样本如下（每行是一个人的身高和体重）：
>
>   $\mathbf{X} = \begin{bmatrix} 170 & 65 \\ 160 & 55 \\ 180 & 75 \end{bmatrix}$
>
>   - 平均值： $\mathbb{E}[X_1] = 170, \quad \mathbb{E}[X_2] = 65$
>   - 方差和协方差计算： $\mathrm{Var}(X_1) = \frac{(170-170)^2 + (160-170)^2 + (180-170)^2}{3} = 66.67 $
>   - $\mathrm{Var}(X_2) = \frac{(65-65)^2 + (55-65)^2 + (75-65)^2}{3} = 66.67 $
>   - $\mathrm{Cov}(X_1, X_2) = \frac{(170-170)(65-65) + (160-170)(55-65) + (180-170)(75-65)}{3} = 66.67$
>
> - 协方差矩阵：
>
>   $\mathbf{Cov}(\mathbf{X}) = \begin{bmatrix} 66.67 & 66.67 \\ 66.67 & 66.67 \end{bmatrix}$
>
> **解释**：
>
> - 身高和体重的协方差是正的，说明它们是正相关的（身高越高，体重越大）。
> - 方差的值相同，表明身高和体重的分布范围相似。
>
> ------
>
> ### 4. **应用场景**
>
> 协方差矩阵广泛应用于各种领域，例如：
>
> 1. 机器学习和统计学：
>    - 主成分分析（PCA）：通过协方差矩阵确定数据的主方向。
>    - 回归分析：通过协方差矩阵判断变量之间的相关性。
> 2. 卡尔曼滤波：
>    - 在状态估计中，协方差矩阵用于描述估计误差和过程噪声的分布。
> 3. 金融分析：
>    - 投资组合优化：协方差矩阵用于描述资产收益之间的相关性，帮助降低投资风险。
>
> ------
>
> ### 5. **总结**
>
> - 协方差矩阵是描述多维随机变量分布特性的重要工具，既包含变量的离散程度（方差），也包含它们之间的关系（协方差）。
> - 在实际问题中，它有助于捕捉数据的内在结构，为模型预测和分析提供基础。



![img](https://pic3.zhimg.com/v2-9881cf44ee7876b2689a901f53afc0b6_1440w.jpg)



# 二、**马氏距离（Mahalanobis Distance）**

**马氏距离**是一种衡量点与点、点与分布之间距离的度量方式，特别适用于高维数据中考虑数据分布的相关性。它在统计分析、机器学习等领域中广泛应用，尤其适合数据具有相关性或不同尺度的情况。

------

## **1. 马氏距离的定义**

对于一个数据点$\mathbf{x}$ 和一个多维分布的中心 $\mathbf{\mu}$，马氏距离定义为：

$D_M(\mathbf{x}) = \sqrt{(\mathbf{x} - \mathbf{\mu})^T \mathbf{\Sigma}^{-1} (\mathbf{x} - \mathbf{\mu})}$

其中：

- ==$\mathbf{x}$：一个待测点（向量）。==
- ==$\mathbf{\mu}$：数据的均值向量（分布中心）。==
- $\mathbf{\Sigma}$：协方差矩阵，描述数据各维度之间的相关性。
- $\mathbf{\Sigma}^{-1}$：协方差矩阵的逆矩阵。
- $(\mathbf{x} - \mathbf{\mu})^T$：表示数据点到中心的偏差向量。

==马氏距离可以理解为一种归一化的距离，它考虑了数据的尺度差异和相关性。==

------

## **2. 马氏距离的核心特点**

1. **考虑变量间的相关性**：
   - 如果两个维度（特征）之间存在相关性，马氏距离会通过协方差矩阵消除相关性的影响。
   - 比如，在二维数据中，特征 x 和 y 高度相关时，欧几里得距离会误导性地放大两个点之间的距离，而马氏距离可以纠正这一问题。
2. **与数据分布相关**：
   - ==马氏距离依赖于数据的分布。当协方差矩阵为单位矩阵时，马氏距离退化为标准的欧几里得距离。==
3. **无量纲化**：
   - 马氏距离对数据的量纲（单位）不敏感，因为它对数据进行了标准化处理。

------

## **3. 马氏距离的几何意义**

- ==在马氏距离的度量下，等距离点构成的几何图形是椭球体，而不是欧几里得距离中的球体。==
- ==**椭球形的主轴方向**和**长短**由协方差矩阵的特征值和特征向量决定。==

例如：

- 如果某个维度的方差较大，则沿着该方向的马氏距离会较短（变化较小，数值稳定）。
- 如果某个维度的方差较小，则沿着该方向的马氏距离会较长（对变化敏感）。

------

## **4. 马氏距离的应用**

### **(1) 异常检测**

- 马氏距离可以用于判断某个数据点是否是异常点（outlier）。
- 如果某点的马氏距离远大于预期范围（通常定义在椭球体内），可以认为它是异常点。

### **(2) 聚类分析**

- 在高维数据中，马氏距离比欧几里得距离更适合用于聚类，特别是当数据具有相关性或特征方差差异较大时。

### **(3) 目标跟踪（DeepSORT 中的应用）**

- 在 DeepSORT 中，马氏距离用于计算检测框（观测值）和轨迹预测值（卡尔曼滤波的预测）之间的距离，结合协方差矩阵对预测的不确定性进行调整，从而更精确地关联目标。

### **(4) 降维与分类**

- 在线性判别分析（LDA）中，马氏距离用于分类任务，以判别数据点更接近哪个类别的分布。

------

## **5. 示例：二维数据中的马氏距离**

假设有一个二维分布，其均值为：

$\mathbf{\mu} = \begin{bmatrix} 2 \\ 3 \end{bmatrix}$

协方差矩阵为：

$\mathbf{\Sigma} = \begin{bmatrix} 2 & 1 \\ 1 & 2 \end{bmatrix}$

一个点 $\mathbf{x} = \begin{bmatrix} 3 \\ 5 \end{bmatrix}$

计算马氏距离：

1. 计算偏差向量：

   $\mathbf{x} - \mathbf{\mu} = \begin{bmatrix} 3 - 2 \\ 5 - 3 \end{bmatrix} = \begin{bmatrix} 1 \\ 2 \end{bmatrix}$

2. 计算协方差矩阵的逆：

   $\mathbf{\Sigma}^{-1} = \begin{bmatrix} 2 & 1 \\ 1 & 2 \end{bmatrix}^{-1} = \frac{1}{3} \begin{bmatrix} 2 & -1 \\ -1 & 2 \end{bmatrix}$

3. 计算马氏距离：

   $D_M = \sqrt{\begin{bmatrix} 1 & 2 \end{bmatrix} \cdot \frac{1}{3} \begin{bmatrix} 2 & -1 \\ -1 & 2 \end{bmatrix} \cdot \begin{bmatrix} 1 \\ 2 \end{bmatrix}}$

   $= \sqrt{\frac{1}{3} \begin{bmatrix} 1 & 2 \end{bmatrix} \begin{bmatrix} 0 \\ 3 \end{bmatrix}} = \sqrt{\frac{1}{3} \cdot 6} = \sqrt{2}$

马氏距离为$\sqrt{2}$。

------

## **6. 与欧几里得距离的对比**

| 特性               | 欧几里得距离               | 马氏距离                     |
| ------------------ | -------------------------- | ---------------------------- |
| **定义**           | 点到点的直线距离           | ==点到分布中心的归一化距离== |
| **考虑变量相关性** | 不考虑                     | 考虑协方差矩阵中的相关性     |
| **单位敏感性**     | 受数据量纲影响             | 不受单位影响                 |
| **适用场景**       | 变量独立、同尺度分布的情况 | 高维相关性数据的距离度量     |

------

## **总结**

马氏距离是一种适合高维分布数据的度量方法，尤其适合考虑变量相关性和不同尺度的问题。在 DeepSORT 中，它用于精确计算检测框和轨迹之间的距离，结合卡尔曼滤波的不确定性（协方差）来提高跟踪效果。



# 三、REID

在目标跟踪（尤其是 **DeepSORT**）中，**ReID（Re-identification，目标重识别）** 的主要作用是为检测到的目标提供外观特征信息，以补充运动信息，从而更好地实现目标的持续跟踪，尤其是在多目标跟踪中。下面从 **定义、作用、应用场景和优缺点** 四个方面详细说明。

------

## **1. ReID 的定义**

ReID 是一种计算机视觉技术，用于在不同场景或时间段中重新识别某个目标。它主要通过提取目标的外观特征（如颜色、纹理、形状等）来进行匹配和识别。对于目标跟踪，ReID 模块负责从检测框中提取目标的外观特征向量。

==在 **DeepSORT** 中，ReID 模块通常是一个预训练的深度学习模型（如 CNN、ResNet），输入目标的图像（通常是检测框区域），输出一个固定长度的特征向量（Feature Vector），例如 128 维或 256 维。==

------

## **2. ReID 的作用**

 **2.1 弥补运动信息不足**

- 在目标跟踪中，卡尔曼滤波器通过目标的运动轨迹预测目标下一帧的位置。然而，运动信息在以下情况下可能失效：
  - **遮挡**：当目标被部分或完全遮挡时，仅靠运动信息无法正确关联检测结果和轨迹。
  - **运动模型变化**：目标的运动模式发生剧烈变化（如突然停止或加速）时，运动预测可能出现较大偏差。
  - **目标交叉或重叠**：多个目标重叠在一起时，运动信息难以唯一识别目标。

在上述情况下，ReID 提供的外观特征向量可以有效区分目标，弥补运动信息的不足。

 **2.2 提高多目标跟踪的关联精度**

- 在多目标跟踪中，每一帧都需要将当前检测框与已有轨迹进行关联。ReID 特征通过衡量检测框和轨迹在外观上的相似性，辅助运动信息完成数据关联。
- 通常，==DeepSORT 会结合 **马氏距离（基于运动信息）** 和 **ReID 特征向量的余弦相似度（基于外观信息）**，构造代价矩阵进行目标匹配，从而提高关联精度。==

**2.3 实现目标的长时间跟踪**

- 当目标短暂丢失后（例如进入遮挡区域），其运动轨迹可能中断。通过 ReID 提取的外观特征，可以在目标重新出现时进行重新关联，从而实现目标的长时间跟踪。
- 例如，==在行人跟踪中，ReID 模块可以根据行人的衣服颜色和外观信息，重新识别同一目标。==

------

## **3. 应用场景**

 **3.1 行人多目标跟踪**

- 在监控视频中跟踪行人，ReID 特征可以利用行人的衣服颜色、纹理等信息，帮助区分多个外观相似的行人。
- 即使行人短暂离开视野，ReID 模块可以帮助重新关联目标。

 **3.2 车辆多目标跟踪**

- 通过车辆的外观特征（如车身颜色、车牌号等），ReID 模块可以在不同摄像头视角或不同时间段内重新识别同一辆车。

**3.3 视频多目标跟踪与分析**

- 在跨镜头跟踪（跨不同摄像头视角）中，运动信息往往不足。ReID 可以通过外观特征完成目标的全局跟踪。

------

## **4. ReID 在 DeepSORT 中的具体流程❤️**

1. **输入检测框：** ==将检测器提供的目标框（目标检测算法）裁剪出目标图像。==
2. **提取外观特征：** ==使用预训练的 ReID 模型（如基于 ResNet 的深度网络）提取固定长度的特征向量。==
3. 计算相似度：
   - ==将当前检测框的 ReID 特征向量与已有轨迹的特征向量库进行匹配。==
   - ==相似性通常通过 **余弦相似度** 或 **欧式距离** 衡量，值越大表示外观越相似。==
4. **融合匹配：** ==将 ReID 特征相似度与运动信息（马氏距离）结合，用于检测框和轨迹的最终关联==。

------

## **5. ReID 的优缺点**

 **优点**

1. **弥补运动信息的不足：** 特别是在遮挡或轨迹中断时，外观信息至关重要。
2. **提高跟踪鲁棒性：** 即使多个目标重叠或轨迹预测误差较大，ReID 特征仍能帮助区分不同目标。
3. **跨视角跟踪：** 在多摄像头系统中，ReID 特征可以实现不同摄像头下的同一目标匹配。

 **缺点**

1. **对外观变化敏感：** 如果目标的外观特征发生明显变化（如衣物更换），ReID 模块可能失效。
2. **计算代价较高：** 提取 ReID 特征需要通过深度网络处理每个检测框，计算量较大。
3. **依赖训练数据：** ReID 模型需要大量有代表性的训练数据来学习目标的外观特征，如果数据不足，可能无法很好地泛化到新场景。

------

## **6. 总结**

在 **DeepSORT** 中，ReID 的作用是提取目标的外观特征，用于检测框和轨迹的匹配关联，特别是当运动信息不足时，它弥补了单纯基于运动模型跟踪的局限性。通过结合 ReID 特征和运动信息，DeepSORT 能够实现鲁棒、高精度的多目标跟踪，特别适用于行人跟踪和车辆跟踪等场景。

# 四、Matching Cascade 

![image-20241122173354858](C:/Users/HUAWEI/AppData/Roaming/Typora/typora-user-images/image-20241122173354858.png)

## **1. 检测器输出**

- 目标检测器（例如 YOLO、Faster R-CNN 等）在当前帧检测到所有目标，输出一组检测框。 
  - 每个检测框 $z_k = [x, y, s, r] $包括目标的位置（中心坐标）、尺度（面积）和宽高比。

------

## **2. 特征提取（ReID）**

- 对检测框的图像区域（例如，目标的裁剪图像）通过 ReID 模型提取外观特征向量 $f_k$（例如 128 维的特征向量）。
- 这些特征向量用来评估检测框与现有轨迹之间的外观相似性。

------

## **3. 匹配代价矩阵的生成❤️❤️**

- **代价矩阵 C** 维度为 $m \times n$，其中 m 是当前检测框数量，n 是现有轨迹数量。
- 每个元素 $C_{i,j}$表示第 i个检测框与第 j条轨迹的匹配代价，通常基于以下两种信息计算：
  1. 运动信息（马氏距离）：
     - ==利用卡尔曼滤波的预测值 $x_k'$ 和检测框 $z_k$，计算运动上的相似性。==
  2. 外观信息（余弦相似度）：
     - ==检测框的 $ReID 特征 f_k$ 与轨迹的特征历史库进行比较，计算余弦相似度。==
  3. 代价组合：
     - 一般将运动信息作为主要依据，外观信息作为辅助==筛选==标准。例如：
       - 对马氏距离进行阈值筛选（过滤代价过高的检测框）。
       - 对余弦相似度也设定阈值（排除外观差异过大的候选项）。

> ### ==**1. 马氏距离的计算**==
>
> 在 DeepSORT 中，马氏距离衡量了检测框 $z_k$ 和轨迹预测值 $x_k' $的运动一致性。具体计算方式如下：
>
> ------
>
> #### **公式**
>
> 马氏距离的计算公式是：
>
> $d_1^2 = (z_k - Hx_k')^T S^{-1} (z_k - Hx_k')$
>
> 其中：
>
> - ==$z_k$：检测框的观测值（目标检测器的输出）。==
>
> - ==$Hx_k'$：卡尔曼滤波的预测值（轨迹预测的状态量经过测量矩阵 H 转换到检测框的空间）。==
>
> - ==S：卡尔曼滤波器的预测协方差矩阵，==计算公式为：
>
>   $S = HP_k'H^T + R$
>
>   - $P_k'$：预测状态的协方差矩阵。
>   - R：观测噪声协方差矩阵（表示检测框的测量不确定性）。
>
> #### **计算步骤**
>
> 1. **残差**：计算观测值和预测值的差异： $r = z_k - Hx_k'$
> 2. 协方差矩阵 S：
>    - 表示观测空间中的不确定性，用来缩放残差。
> 3. **最终距离**：将残差投影到协方差矩阵的逆中： $d_1 = \sqrt{r^T S^{-1} r}$
>
> **注意：** 马氏距离不仅考虑了检测框与预测值之间的欧式距离，还结合了检测框测量的不确定性，使其更加鲁棒。
>
> ------
>
> ### ==**2. 余弦相似度的计算**==
>
> 在 DeepSORT 中，余弦相似度用于衡量检测框和轨迹的外观一致性。它通过 ReID 提取的外观特征向量来计算。
>
> ------
>
> #### **公式**
>
> 余弦相似度的公式是：
>
> ==$\text{Cosine Similarity} = \frac{f_i \cdot f_j}{\|f_i\| \|f_j\|}$==
>
> 其中：
>
> - ==$f_i$：检测框的 ReID 特征向量。==
> - ==$f_j$：轨迹的 ReID 特征向量（通常是该轨迹历史帧特征的均值向量）。==
> - ==$\|f\|$：特征向量的 $L_2$ 范数。==
>
> #### **计算步骤**
>
> 1. 提取特征向量：
>    - 使用 ReID 模型提取当前检测框和轨迹历史帧的特征。
> 2. 归一化：
>    - 将特征向量进行 $L_2 $归一化，使得向量长度为 1。
> 3. 内积：
>    - 计算归一化后的特征向量之间的点积，得到相似度值。
> 4. 代价矩阵中的距离表示：
>    - ==将相似度转换为距离： $d_2 = 1 - \text{Cosine Similarity}$==
>
> ------
>
> ### **3. 两者的综合代价**
>
> DeepSORT 中最终的综合代价矩阵 C 结合了马氏距离和余弦相似度：
>
> ==$C = \lambda d_1 + (1-\lambda) d_2$==
>
> 其中：
>
> - $\lambda$ 是权重参数，用于平衡运动信息（马氏距离）和外观信息（余弦相似度）的重要性。
>
> ------
>
> ### **应用示例**
>
> #### ==**马氏距离示例：**==
>
> - 一个目标在上一帧出现在坐标 (100, 200)，预测其下一帧可能的坐标为 (105, 210)。
> - 实际检测框的坐标为 (110, 215)。
> - 使用卡尔曼滤波提供的协方差矩阵 S，计算两者的马氏距离，判断其运动匹配度。
>
> #### ==**余弦相似度示例：**==
>
> - 当前检测框通过 ReID 提取特征向量 $f_i = [0.2, 0.8, 0.4]。$
> - 历史轨迹的特征向量均值为 $f_j = [0.1, 0.9, 0.5]。$
> - 计算两者的归一化点积，得到外观相似性。
>
> **总结：**
>  马氏距离和余弦相似度分别处理了运动一致性和外观一致性的问题，通过综合代价矩阵实现两者的平衡，使得 DeepSORT 能够在复杂场景下进行更精确的目标匹配。

------

## **4. Matching Cascade 进行多层级匹配❤️**

- ==**Matching Cascade** 是一种分层匹配策略，旨在优先匹配高置信度轨迹，逐层降低优先级==。
  - **第一层：** 先匹配年龄（即未匹配帧数较少）的轨迹。
  - **第二层：** 然后匹配年龄较大的轨迹（优先关联最近观察到的目标）。
  - **未匹配项：** 对剩余未匹配的轨迹和检测框进行后续处理（创建新轨迹或删除失效轨迹）。
- 在每一层中：
  - 将代价矩阵 C 提交给匈牙利算法，找到检测框与轨迹的最优匹配。
  - 匹配结果：
    - 成功匹配的检测框和轨迹直接更新。
    - 未匹配的检测框可能创建新轨迹。
    - 未匹配的轨迹可能被标记为失效（如果持续多帧未匹配，可能会被删除）。

> ==**Matching Cascade** 中的确是按照 **轨迹的优先级分阶段** 来计算代价矩阵和匹配的。因此，如果有多个 **confirmed tracks** 和 **检测框**。代价矩阵是一个，按照优先级逐步匹配多次。==
>
> ------
>
> ### **Matching Cascade 的代价矩阵计算与分阶段匹配**
>
> Matching Cascade 的关键是：
>
> 1. **分阶段匹配**：从高优先级的轨迹（例如，confirmed tracks 中最近被更新的轨迹）到低优先级的轨迹（如更久未更新的轨迹）。
> 2. ==每个阶段只考虑一个优先级的轨迹，并计算当前轨迹集合与所有检测框的代价矩阵。==
>
> ------
>
> #### **具体流程**
>
> 1. **轨迹按优先级分类**：
>    - $A_{\text{max}}$：最大允许的轨迹优先级，例如，最近更新过的轨迹为最高优先级（age = 0）。
>    - A：轨迹优先级，随着轨迹未匹配的帧数增加，优先级降低。
> 2. **阶段性匹配**：
>    - 在每个阶段，选择优先级为 A = n 的轨迹集合，计算该集合与当前检测框集合的代价矩阵。
>    - 对每一阶段的匹配：
>      - **计算代价矩阵 C**：结合运动（马氏距离）和外观（余弦距离）。
>      - **匈牙利算法匹配**：只在当前阶段的轨迹和检测框中执行。
>      - 匹配成功的检测框将被移出后续阶段的匹配。
> 3. **逐阶段迭代**：
>    - 优先匹配高优先级的轨迹。
>    - 如果有未匹配的检测框或轨迹，则在下一阶段尝试匹配低优先级的轨迹。
> 4. **未匹配处理**：
>    - 剩余未匹配的轨迹被标记为丢失。
>    - 剩余未匹配的检测框被初始化为新轨迹。
>
> ------
>
> ### **阶段性匹配的意义**
>
> - **提高计算效率**：每次只匹配小规模的轨迹集合，减少了直接计算所有轨迹和检测框代价矩阵的复杂度。
> - **优先保护高优先级轨迹**：确保稳定目标（最近更新过的 confirmed tracks）优先被匹配，避免因新目标或噪声干扰丢失。
> - **鲁棒性**：通过阶段性分配检测框，能够有效处理遮挡和目标混淆等复杂场景。
>
> ------
>
> ### **总结**
>
> - **每个优先级的轨迹（confirmed tracks 按年龄分组）会单独计算一个代价矩阵**。
> - 匹配成功的检测框会从后续计算中移除，逐阶段进行匹配。
> - 这种逐步分阶段匹配的机制是 Matching Cascade 的核心特点，能够显著提升目标跟踪的稳定性和效率。

------

## **5. 卡尔曼滤波调整轨迹：**

- ==对于成功匹配的轨迹，结合检测框 $z_k$ 和轨迹的预测状态 $x_k'$，通过卡尔曼滤波的更新步骤进行状态修正：==
  - 输入：
    - 预测值 $x_k'$：上一帧轨迹通过状态转移模型得到的预测状态。
    - 观测值 $z_k$：当前帧检测器提供的检测框。
  - 输出：
    - 修正后的轨迹状态 $x_k$。
    - 更新的协方差矩阵 $P_k$，反映当前状态的不确定性。
- **卡尔曼滤波的作用：**
  - 平滑轨迹，减小检测误差的影响（例如噪声、抖动）。
  - 预测下一帧轨迹的位置，为下一帧的匹配提供参考。

------

## **总结流程**

以下是完整的 **Matching Cascade** 流程：

1. **检测器输出**：当前帧中的目标检测框 $z_k$。
2. **ReID 特征提取**：提取检测框的外观特征。
3. **生成代价矩阵**：根据马氏距离（运动信息）和余弦相似度（外观信息）计算匹配代价。
4. 匹配阶段：
   - 使用 Matching Cascade 策略，优先匹配高置信度轨迹。
   - 每一层用匈牙利算法找到检测框与轨迹的最优匹配。
5. 卡尔曼滤波修正：
   - 利用匹配结果，更新轨迹状态 $x_k$ 和协方差矩阵。
6. 轨迹管理：
   - 对未匹配的检测框：创建新轨迹。
   - 对未匹配的轨迹：根据未匹配次数决定是否删除。 

------



![image-20241122195054725](C:/Users/HUAWEI/AppData/Roaming/Typora/typora-user-images/image-20241122195054725.png)



# 五、卡尔曼滤波预测的confirmed与unconfirmed

在卡尔曼滤波的目标跟踪应用中，**confirmed（确认）**和**unconfirmed（未确认）**通常用来描述目标的状态，反映了当前跟踪目标是否可信。这些概念广泛应用于多目标跟踪（Multiple Object Tracking, MOT）中，比如目标检测与跟踪算法（如SORT、DeepSORT）中，利用卡尔曼滤波结合匈牙利算法或其他数据关联方法进行匹配。

------

## **1. 定义与含义**

- **Confirmed（确认）：**
- ==表示目标已经经过多次观测确认，具备一定的稳定性，可以认为是一个真正的跟踪目标。==
  
- 符合以下条件：
  
  1. 目标在多帧中成功地被观测到（通过与检测结果匹配）。
    2. 卡尔曼滤波的状态估计稳定，不再依赖单帧检测。
  
- 实际作用：
  
  - 确认目标轨迹的存在。
  - 提高对运动轨迹的置信度。

- **Unconfirmed（未确认）：**

  - ==表示目标尚未经过足够的观测确认，可能是误检或短期噪声引发的虚假目标。==

  - 符合以下条件：

    1. 目标刚刚被检测到，还未经过足够多的连续观测。
    2. 目标轨迹在时间上过短，或检测数据不稳定。

  - 实际作用：

    - 用于标记潜在目标，但在未获得足够数据前不输出。
- 减少因单帧误检而引入的错误轨迹。

------

## **2. 状态切换逻辑**

==在多目标跟踪中，目标状态一般会经历以下阶段：==

1. **初始状态**（Unconfirmed）：
   - 检测到一个目标时，初始化一个轨迹。
   - 如果轨迹在后续帧中无法找到匹配的检测，直接删除。
2. **确认状态**（Confirmed）：
   - 当某一目标轨迹在多帧内持续匹配检测数据（超过设定的帧数阈值，例如3帧），其状态会被标记为**Confirmed**。
   - 确认的轨迹会被认为是一个有效目标，保留输出。
3. **删除状态**（Deleted）：
   - 如果目标轨迹在若干帧内未能与检测数据匹配（例如因为目标离开视野），轨迹将被删除。

------

## **3. 如何使用卡尔曼滤波实现**

卡尔曼滤波在预测与更新阶段会结合目标的状态（Confirmed 或 Unconfirmed）进行处理：

1. **预测阶段（Prediction）：**

   - ==无论目标是已确认还是未确认，都通过状态模型预测其下一时刻的位置。==

2. **更新阶段（Update）：**

   - Confirmed：

     - 如果有观测数据匹配当前轨迹，更新卡尔曼状态。
  - 如果未找到匹配，状态预测的不确定性增加（协方差增大）。
    
   - Unconfirmed：

     - 如果在设定帧数内找到匹配，转为**Confirmed**。
- 如果未找到匹配且帧数超过阈值，删除轨迹。

------

## **4. 实际应用中的例子**

以目标跟踪为例（例如 DeepSORT）：

 **场景**

视频中一个行人从右侧走进视野，逐渐靠近摄像头，之后离开。

**处理过程**

1. **初始化轨迹（Unconfirmed）：**
   - 初次检测到目标，卡尔曼滤波初始化位置和速度状态。
   - 系统暂时不输出此轨迹，等待进一步确认。
2. **确认轨迹（Confirmed）：**
   - 如果目标连续3帧内被检测到且与预测匹配，轨迹状态切换为**Confirmed**。
   - 目标位置被平滑估计，系统输出轨迹。
3. **删除轨迹（Deleted）：**
   - 当目标离开视野或未被检测到，卡尔曼滤波只进行预测。
   - 如果未匹配检测数据的帧数超过设定阈值（例如10帧），轨迹被删除。

------

## **总结**

1. **Confirmed**和**Unconfirmed**主要用于描述轨迹是否稳定。
2. **Unconfirmed**适合处理短期误检，避免虚假轨迹的输出。
3. 卡尔曼滤波在这些状态间切换时，通过观测数据的匹配情况动态调整轨迹状态。
4. 在目标跟踪实际应用中，利用这些状态可以更稳健地管理轨迹，提升跟踪系统的准确性和可靠性。

# 六、

iou：目标检测框与预测框进行iou匹配--代价矩阵
