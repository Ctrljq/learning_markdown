# 1、切片

```py
# img是（1，3，6，3，480，800）
prev_img = img[:, :-1, ...]  
img = img[:, -1, ...] 
```

### 代码逐步解析



```py
prev_img = img[:, :-1, ...]
```

1. 切片操作：

   ```py
   img[:, :-1, ...]
   ```

   - `:` 表示保留所有批次（`batch size`）。
   - `:-1` 表示对时间帧（第二个维度）取从开始到倒数第 2 个（不包含最后一个）。
   - `...` 表示保留剩余所有维度（即 `6, 3, 480, 800`）。

   所以，

   ```
   prev_img
   ```

    的形状变为：

   ```
   (1, 2, 6, 3, 480, 800)
   ```

```py
img = img[:, -1, ...]
```

1. 取最后一个时间帧：

   ```
   img[:, -1, ...]
   ```

   - `:` 表示保留所有批次（`batch size`）。
   - `-1` 表示取时间帧的最后一个帧。
   - `...` 表示保留剩余所有维度（即 `6, 3, 480, 800`）。

   取切片后，img的形状变为：

   ```
   (1, 6, 3, 480, 800)
   ```

   ==结果不是 `(1, 1, 6, 3, 480, 800)` 的原因是 **`img[:, -1, ...]` 会自动去掉切片后的单一维度**。这种行为源于 NumPy 和 PyTorch 的张量操作规则，称为**单元素维度压缩（squeeze-like behavior）**。==

------

### 总结代码运行中形状变化

1. 原始 `img`：`(1, 3, 6, 3, 480, 800)`。
2. 提取 `prev_img`：`(1, 2, 6, 3, 480, 800)`（前两个时间帧）。
3. 更新 `img`：`(1, 6, 3, 480, 800)`（最后一个时间帧）。

2、transpose与permute

`transpose` 只能交换 **两个维度** 的位置。

`permute` 可以任意调整多个维度的顺序。