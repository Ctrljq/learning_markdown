# 一、基础语法知识

## 1、使用三引号(**'''** 或 **"""**)可以指定一个多行字符串

- 使用三引号(**'''** 或 **"""**)可以指定一个多行字符串。输出格式也和输入格式相同
- 反斜杠可以用来转义，使用 **r** 可以让反斜杠不发生转义。 如 **r"this is a line with \n"** 则 **\n** 会显示，并不是换行。

![image-20240910162425778](C:/Users/HUAWEI/AppData/Roaming/Typora/typora-user-images/image-20240910162425778.png)

## 2、字符串是**不可变的**

在 Python 中，字符串是**不可变的**，意思是**一旦创建，字符串的内容就不能被修改**。如果你想修改字符串，实际上会创建一个新的字符串对象，而不是修改原来的字符串。Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。

举个例子：

```py
python复制代码s = "hello"
s[0] = "H"  # 试图修改字符串中的第一个字符
```

这段代码会抛出 `TypeError`，因为 Python 中的字符串不允许这样直接修改。

如果你需要修改字符串中的某些部分，可以通过创建一个新字符串来实现，比如使用字符串拼接：

```py
python复制代码s = "hello"
s = "H" + s[1:]  # 创建了一个新字符串 "Hello"
print(s)  # 输出: Hello
```

这里的 `s` 变量指向了一个新的字符串 `"Hello"`，而原来的字符串 `"hello"` 仍然存在于内存中（如果没有被引用，将会被垃圾回收机制回收）。

## 3、字符串切片 

字符串切片**str[start:end]**，其中 start（包含）是切片开始的索引，==end（不包含）是切片结束的索引==。

字符串的切片可以加上步长参数 step，语法格式如下：`str[start:end:step]`

## 4、字符串运算符

字符串可以用 **+** 运算符连接在一起，用 ***** 运算符重复

![QQ_1725958651923](C:/Users/HUAWEI/AppData/Local/Temp/QQ_1725958651923.png)

## 5、同一行中使用多条语句

Python 可以在同一行中使用多条语句，语句之间使用分号 **;**

![](C:/Users/HUAWEI/AppData/Local/Temp/QQ_1725959209452.png)

## 6、print输出

**print** 默认输出是换行的，如果要实现不换行需要在变量末尾加上 **end=""**：

```py
x="a"
y="b"
# 换行输出
print( x )
print( y )
 
print('---------')
# 不换行输出
print( x, end=" " )
print( y, end=" " )
print()
```

```yaml
a
b
---------
a b
```

## 7、import 与 from...import

将整个模块(somemodule)导入，格式为： **import somemodule**

从某个模块中导入某个函数,格式为： **from somemodule import somefunction**

从某个模块中导入多个函数,格式为： **from somemodule import firstfunc, secondfunc, thirdfunc**

将某个模块中的全部函数导入，格式为： **from somemodule import \***

## 8、命令行参数

**`sys.argv`**:这是一个包含命令行参数的列表。`sys.argv[0]` 通常是脚本的文件名，后面的元素是传递给脚本的参数。

```py
#C:\Users\HUAWEI\PycharmProjects\mamba_out\.venv\week1\lebronjames.py
import sys

# 第一个参数是脚本名称，从第二个开始是传入的参数
print(f"Script name: {sys.argv[0]}")
print(f"First argument: {sys.argv[1]}")
print(f"Second argument: {sys.argv[2]}")
```

![QQ_1725960553907](C:/Users/HUAWEI/AppData/Local/Temp/QQ_1725960553907.png)

# 二、基本数据类型

Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。

在 Python 中，变量就是变量，它没有类型，我们所说的"类型"是变量所指的内存中对象的类型。

## 1、多个变量赋值

```py
a = b = c = 1
a, b, c = 1, 2, "runoob"
```

## 2、**不可变**和**可变**数据类型

| 类型           | 是否可变 | 示例                           |
| -------------- | -------- | ------------------------------ |
| **Number**     | 不可变   | `int`, `float`, `complex`      |
| **String**     | 不可变   | `"hello"`, `"world"`           |
| **Tuple**      | 不可变   | `(1, 2, 3)`                    |
| **List**       | 可变     | `[1, 2, 3]`                    |
| **Dictionary** | 可变     | `{"name": "Alice", "age": 25}` |
| **Set**        | 可变     | `{1, 2, 3}`                    |

不可变的数据类型在某些情况下效率更高，适合用作字典的键（`tuple` 是可以的，`list` 不行），而可变数据类型提供了更大的灵活性用于操作和存储动态数据。

### 2.1. **不可变数据类型**

不可变数据类型是指**一旦创建**后，**无法改变其内容**的类型。如果尝试修改它们，会生成一个新的对象，而不是在原对象上直接修改。

- **Number（数字）**：

  - Python 中的数字类型包括 `int`（整数）、`float`（浮点数）、`complex`（复数）等。
  - 例如，整数 `5` 是不可变的。如果你将它加上 1，得到的结果是新的数字 `6`，而不是修改原来的 `5`。

  ```py
  x = 5
  y = x + 1  # 产生新的值 6，而不是修改 x
  ```

- **String（字符串）**：

  - 字符串也是不可变的。一旦定义了一个字符串，就无法直接修改它的内容，任何字符串操作都会返回一个新字符串。

  ```py
  s = "hello"
  s[0] = "H"  # 会报错，因为字符串不可变
  s = s.replace("h", "H")  # 返回一个新字符串 "Hello"，s 的值也被重新赋值
  ```

- **Tuple（元组）**：

  - 元组是不可变的序列。和列表类似，但它的元素不能被修改或删除。添加或修改元素会生成一个新的元组。

  ```py
  t = (1, 2, 3)
  t[0] = 4  # 会报错，因为元组不可变
  ```

### 2.2. **可变数据类型**

可变数据类型是指可以**直接修改其内容**，而不需要创建新的对象。

- **List（列表）**：

  - 列表是有序的、可变的序列。可以随时添加、删除、修改列表中的元素。

  ```py
  lst = [1, 2, 3]
  lst[0] = 4  # 修改第一个元素，lst 变为 [4, 2, 3]
  lst.append(5)  # 添加新元素，lst 变为 [4, 2, 3, 5]
  ```

- **Dictionary（字典）**：

  - 字典是键值对的无序集合，可以根据键来修改对应的值，也可以添加或删除键值对。

  ```python
  d = {"name": "Alice", "age": 25}
  d["age"] = 26  # 修改字典中的 age，d 变为 {"name": "Alice", "age": 26}
  d["city"] = "New York"  # 添加新键值对，d 变为 {"name": "Alice", "age": 26, "city": "New York"}
  ```

- **Set（集合）**：

  - 集合是无序的、唯一元素的集合。可以在集合中添加或删除元素。

  ```python
  s = {1, 2, 3}
  s.add(4)  # 添加元素 4，s 变为 {1, 2, 3, 4}
  s.remove(2)  # 删除元素 2，s 变为 {1, 3, 4}
  ```

## 3、数据类型判断

内置的 type() 函数可以用来查询变量所指的对象类型。

![QQ_1725964398833](C:/Users/HUAWEI/AppData/Local/Temp/QQ_1725964398833.png)

此外还可以用 isinstance 来判断

![QQ_1725964434835](C:/Users/HUAWEI/AppData/Local/Temp/QQ_1725964434835.png)

**`is` 运算符** 用来判断两个对象是否**引用同一个内存地址**。它比较的是对象的**身份**，而不是对象的值。

![QQ_1725964690687](C:/Users/HUAWEI/AppData/Local/Temp/QQ_1725964690687.png)

## 4、bool

- 可以使用 `bool()` 函数将其他类型的值转换为布尔值。以下值在转换为布尔值时为 `False`：`None`、`False`、零 (`0`、`0.0`、`0j`)、空序列（如 `''`、`()`、`[]`）和空映射（如 `{}`）。其他所有值转换为布尔值时均为 `True`。

```py
# 布尔类型的值和类型
a = True
b = False
print(type(a))  # <class 'bool'>
print(type(b))  # <class 'bool'>

# 布尔类型的整数表现
print(int(True))   # 1
print(int(False))  # 0

# 使用 bool() 函数进行转换
print(bool(0))         # False
print(bool(42))        # True
print(bool(''))        # False
print(bool('Python'))  # True
print(bool([]))        # False
print(bool([1, 2, 3])) # True

# 布尔逻辑运算
print(True and False)  # False
print(True or False)   # True
print(not True)        # False

# 布尔比较运算
print(5 > 3)  # True
print(2 == 2) # True
print(7 < 4)  # False

# 布尔值在控制流中的应用
if True:
    print("This will always print")
    
if not False:
    print("This will also always print")
    
x = 10
if x:
    print("x is non-zero and thus True in a boolean context")
```

## 5、列表

列表是写在方括号 **[]** 之间、用逗号分隔开的元素列表。

和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。

<img src="https://www.runoob.com/wp-content/uploads/2014/08/list_slicing1_new1.png" alt="img" style="zoom: 50%;" />

与Python字符串不一样的是，列表中的元素是可以改变的

![QQ_1725965598036](C:/Users/HUAWEI/AppData/Local/Temp/QQ_1725965598036.png)

> **注意：**
>
> - 1、列表写在方括号之间，元素用逗号隔开。
> - 2、和字符串一样，列表可以被索引和切片。
> - 3、列表可以使用 **+** 操作符进行拼接。
> - 4、列表中的元素是可以改变的。
>
> Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串：

如果第三个参数为负数表示逆向读取，以下实例用于翻转字符串：

```py
def reverseWords(input): 
      
    # 通过空格将字符串分隔符，把各个单词分隔为列表
    inputWords = input.split(" ") 
  
    # 翻转字符串
    # 假设列表 list = [1,2,3,4],  
    # list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样) 
    # inputWords[-1::-1] 有三个参数
    # 第一个参数 -1 表示最后一个元素
    # 第二个参数为空，表示移动到列表末尾
    # 第三个参数为步长，-1 表示逆向
    inputWords=inputWords[-1::-1] 
  
    # 重新组合字符串
    output = ' '.join(inputWords) 
      
    return output 
  
if __name__ == "__main__": 
    input = 'I like runoob'
    rw = reverseWords(input) 
    print(rw)
```

```yaml
runoob like I
```

## 6、元组

```py
#!/usr/bin/python3

tuple = ( 'abcd', 786 , 2.23, 'runoob', 70.2  )
tinytuple = (123, 'runoob')

print (tuple)             # 输出完整元组
print (tuple[0])          # 输出元组的第一个元素
print (tuple[1:3])        # 输出从第二个元素开始到第三个元素
print (tuple[2:])         # 输出从第三个元素开始的所有元素
print (tinytuple * 2)     # 输出两次元组
print (tuple + tinytuple) # 连接元组
```

```
('abcd', 786, 2.23, 'runoob', 70.2)
abcd
(786, 2.23)
(2.23, 'runoob', 70.2)
(123, 'runoob', 123, 'runoob')
('abcd', 786, 2.23, 'runoob', 70.2, 123, 'runoob')
```

元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取（看上面，这里不再赘述）。其实，可以把字符串看作一种特殊的元组。

## 7、集合

集合（Set）是一种无序、可变的数据类型，用于存储唯一的元素。

集合中的元素不会重复，并且可以进行交集、并集、差集等常见的集合操作。

> 集合会将字符串视为一个可迭代对象，将其中的每个字符作为单独的元素添加到集合中，并自动去重。
>
> 集合将列表中的每个元素视为独立的元素，添加到集合中，并自动去重。

![QQ_1726043464503](C:/Users/HUAWEI/AppData/Local/Temp/QQ_1726043464503.png)

==集合运算==

```py
# set可以进行集合运算
a = set('abracadabra')
b = set('alacazam')

print(a)

print(a - b)     # a 和 b 的差集

print(a | b)     # a 和 b 的并集

print(a & b)     # a 和 b 的交集

print(a ^ b)     # a 和 b 中不同时存在的元素
```

## 8、字典

**注意：**创建一个空集合必须用 **set()** 而不是 **{ }**，因为 **{ }** 是用来创建一个空字典。

字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。

字典是一种映射类型，字典用 **{ }** 标识，它是一个无序的 **键(key) : 值(value)** 的集合。键(key)必须使用不可变类型。

```py
#!/usr/bin/python3

dict = {}
dict['one'] = "1 - 菜鸟教程"
dict[2]     = "2 - 菜鸟工具"

tinydict = {'name': 'runoob','code':1, 'site': 'www.runoob.com'}


print (dict['one'])       # 输出键为 'one' 的值
print (dict[2])           # 输出键为 2 的值
print (tinydict)          # 输出完整的字典
print (tinydict.keys())   # 输出所有键
print (tinydict.values()) # 输出所有值
```

==构造函数 dict() 可以直接从键值对序列中构建字典==

`dict()` 构造字典时，传入的可迭代对象中每个元素**不一定必须是元组**，也可以是其他具有**两个元素的可迭代对象**，例如**列表**。但**集合**不适合这种情况，因为集合是无序且不能包含重复元素，无法准确地映射到键值对的结构。

```py
# 使用列表作为键值对
dict([['Runoob', 1], ['Google', 2], ['Taobao', 3]])
# 使用元组作为键值对
dict([('Runoob', 1), ('Google', 2), ('Taobao', 3)])
```

## 9、bytes类型

> ### `bytes` 类型的特点：
>
> - **不可变**：类似于字符串，`bytes` 类型的数据一旦创建，就不能修改。
> - **二进制数据**：每个字节的值在 0-255（0x00 到 0xFF）范围内。
> - **使用 `b''` 或 `bytes()` 构造**：用前缀 `b` 表示字节序列。

每个字符会被转换成对应的 ASCII 值。

![QQ_1726045526956](C:/Users/HUAWEI/AppData/Local/Temp/QQ_1726045526956.png)

**使用 `bytes()` 构造函数**

`bytes()` 构造函数可以接受不同类型的参数来创建字节对象。

- **通过字符串编码**： 将字符串编码为字节流（通常使用 UTF-8 编码）。

  ```python
  b = bytes("hello", encoding="utf-8")
  print(b)  # 输出: b'hello'
  ```

- **通过可迭代对象（如列表）**： 列表中的每个元素代表一个字节（0-255 范围内的整数）。

  ```python
  b = bytes([104, 101, 108, 108, 111])
  print(b)  # 输出: b'hello'
  ```

- **通过指定长度**： 创建一个指定长度的空字节序列，每个字节为 0。

  ```python
  b = bytes(5)
  print(b)  # 输出: b'\x00\x00\x00\x00\x00'  (5 个 0)
  ```

  ##  

# 三、数据类型转换

![QQ_1726046113958](C:/Users/HUAWEI/AppData/Local/Temp/QQ_1726046113958.png)

![QQ_1726046098203](C:/Users/HUAWEI/AppData/Local/Temp/QQ_1726046098203.png)

> 在 Python 中，`print()` 函数可以接受多个参数，并用**逗号**分隔。这些参数会依次输出，并且默认用**空格**作为分隔符。因此，逗号在 `print()` 函数中不会被打印，它的作用是分隔多个要打印的值。
>
> ```py
> print("num_int 数据类型为:",type(num_int))
> ```

## 常见转换函数

![QQ_1726046809846](C:/Users/HUAWEI/AppData/Local/Temp/QQ_1726046809846.png)

![QQ_1726046890340](C:/Users/HUAWEI/AppData/Local/Temp/QQ_1726046890340.png)

![QQ_1726046908683](C:/Users/HUAWEI/AppData/Local/Temp/QQ_1726046908683.png)

> ### 支持的操作
>
> 序列类型通常支持以下操作：
>
> - **索引**：通过位置访问元素（如 `s[0]`）。
> - **切片**：访问序列的一部分（如 `s[1:3]`）。
> - **长度**：使用 `len()` 获取序列的长度。
> - **成员检查**：使用 `in` 检查元素是否存在于序列中（如 `'a' in s`）
>
> 可作为序列的数据结构主要包括：
>
> - 不可变序列：`str`、`tuple`、`bytes`、`range`
> - 可变序列：`list`、`bytearray`
>
> 这些数据结构都是有序的，并且支持索引、切片等操作。
>
> | 数据结构                    | 是否可变 | 用途                                       |
> | --------------------------- | -------- | ------------------------------------------ |
> | **列表（`list`）**          | 可变     | 通用、灵活的序列类型，存储任意类型的元素。 |
> | **元组（`tuple`）**         | 不可变   | 类似列表，但不可变，用于存储固定数据。     |
> | **字符串（`str`）**         | 不可变   | 字符序列，表示文本。                       |
> | **范围（`range`）**         | 不可变   | 用于生成整数序列，常用于循环控制。         |
> | **字节序列（`bytes`）**     | 不可变   | 用于存储二进制数据。                       |
> | **字节序列（`bytearray`）** | 可变     | 可变的字节序列，用于处理二进制数据。       |

# 四、运算符

## 1、算术运算符

| 运算符 | 描述                                            | 实例                      |
| :----- | :---------------------------------------------- | :------------------------ |
| +      | 加 - 两个对象相加                               | a + b 输出结果 31         |
| -      | 减 - 得到负数或是一个数减去另一个数             | a - b 输出结果 -11        |
| *      | 乘 - 两个数相乘或是返回一个被重复若干次的字符串 | a * b 输出结果 210        |
| /      | 除 - x 除以 y                                   | b / a 输出结果 2.1        |
| %      | 取模 - 返回除法的余数                           | b % a 输出结果 1          |
| **     | 幂 - 返回x的y次幂                               | a**b 为10的21次方         |
| //     | 取整除 - 往小的方向取整数                       | `>>> 9//2 4 >>> -9//2 -5` |

## 2、比较运算符

## 3、赋值运算符

| :=   | 海象运算符，这个运算符的主要目的是在表达式中同时进行赋值和返回赋值的值。**Python3.8 版本新增运算符**。 | 在这个示例中，赋值表达式可以避免调用 len() 两次:`if (n := len(a)) > 10:    print(f"List is too long ({n} elements, expected <= 10)")` |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
|      |                                                              |                                                              |

## 4、位运算符

| 运算符 | 描述                                                         | 实例                                                         |
| :----- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| &      | 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 | (a & b) 输出结果 12 ，二进制解释： 0000 1100                 |
| \|     | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 | (a \| b) 输出结果 61 ，二进制解释： 0011 1101                |
| ^      | 按位异或运算符：当两对应的二进位相异时，结果为1              | (a ^ b) 输出结果 49 ，二进制解释： 0011 0001                 |
| ~      | 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。**~x** 类似于 **-x-1** | (~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。 |
| <<     | 左移动运算符：运算数的各二进位全部左移若干位，由"<<"右边的数指定移动的位数，高位丢弃，低位补0。 | a << 2 输出结果 240 ，二进制解释： 1111 0000                 |
| >>     | 右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数 | a >> 2 输出结果 15 ，二进制解释： 0000 1111                  |

## 5、逻辑运算符

| 运算符 | 逻辑表达式 | 描述                                                         | 实例                    |
| :----- | :--------- | :----------------------------------------------------------- | :---------------------- |
| and    | x and y    | 布尔"与" - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。 | (a and b) 返回 20。     |
| or     | x or y     | 布尔"或" - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。 | (a or b) 返回 10。      |
| not    | not x      | 布尔"非" - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 | not(a and b) 返回 False |

## 6、成员运算符

除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。

| 运算符 | 描述                                                    | 实例                                              |
| :----- | :------------------------------------------------------ | :------------------------------------------------ |
| in     | 如果在指定的序列中找到值返回 True，否则返回 False。     | x 在 y 序列中 , 如果 x 在 y 序列中返回 True。     |
| not in | 如果在指定的序列中没有找到值返回 True，否则返回 False。 | x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 |

## 7、身份运算符

身份运算符用于比较两个对象的存储单元

| 运算符 | 描述                                        | 实例                                                         |
| :----- | :------------------------------------------ | :----------------------------------------------------------- |
| is     | is 是判断两个标识符是不是引用自一个对象     | **x is y**, 类似 **id(x) == id(y)** , 如果引用的是同一个对象则返回 True，否则返回 False |
| is not | is not 是判断两个标识符是不是引用自不同对象 | **x is not y** ， 类似 **id(x) != id(y)**。如果引用的不是同一个对象则返回结果 True，否则返回 False。 |

**注：** [id()](https://www.runoob.com/python/python-func-id.html) 函数用于获取对象内存地址。

```py
#!/usr/bin/python3
 
a = 20
b = 20
 
if ( a is b ):
   print ("1 - a 和 b 有相同的标识")
else:
   print ("1 - a 和 b 没有相同的标识")
 
if ( id(a) == id(b) ):
   print ("2 - a 和 b 有相同的标识")
else:
   print ("2 - a 和 b 没有相同的标识")
 
# 修改变量 b 的值
b = 30
if ( a is b ):
   print ("3 - a 和 b 有相同的标识")
else:
   print ("3 - a 和 b 没有相同的标识")
 
if ( a is not b ):
   print ("4 - a 和 b 没有相同的标识")
else:
   print ("4 - a 和 b 有相同的标识")
```

```
1 - a 和 b 有相同的标识
2 - a 和 b 有相同的标识
3 - a 和 b 没有相同的标识
4 - a 和 b 没有相同的标识
```

> 在 Python 中，使用切片操作 `a[:]` 会创建一个**浅拷贝**，即生成一个新的列表对象，其内容与原列表相同，但它们是**不同的对象**。这就是为什么 `b is a` 返回 `False` 的原因。
>
> ```py
> >>>a = [1, 2, 3]
> >>> b = a
> >>> b is a 
> True
> >>> b == a
> True
> >>> b = a[:]
> >>> b is a
> False
> >>> b == a
> True
> ```



## 8、运算符优先级

| 运算符                                                       | 描述                               |
| :----------------------------------------------------------- | :--------------------------------- |
| `(expressions...)`,`[expressions...]`, `{key: value...}`, `{expressions...}` | 圆括号的表达式                     |
| `x[index]`, `x[index:index]`, `x(arguments...)`, `x.attribute` | 读取，切片，调用，属性引用         |
| await x                                                      | await 表达式                       |
| `**`                                                         | 乘方(指数)                         |
| `+x`, `-x`, `~x`                                             | 正，负，按位非 NOT                 |
| `*`, `@`, `/`, `//`, `%`                                     | 乘，矩阵乘，除，整除，取余         |
| `+`, `-`                                                     | 加和减                             |
| `<<`, `>>`                                                   | 移位                               |
| `&`                                                          | 按位与 AND                         |
| `^`                                                          | 按位异或 XOR                       |
| `|`                                                          | 按位或 OR                          |
| `in,not in, is,is not, <, <=, >, >=, !=, ==`                 | 比较运算，包括成员检测和标识号检测 |
| `not x`                                                      | 逻辑非 NOT                         |
| `and`                                                        | 逻辑与 AND                         |
| `or`                                                         | 逻辑或 OR                          |
| `if -- else`                                                 | 条件表达式                         |
| `lambda`                                                     | lambda 表达式                      |
| `:=`                                                         | 赋值表达式                         |

```py
x = True
y = False
z = False
 
if x or y and z:     """and优先级高于or"""
    print("yes")         '''打印yes'''
else:
    print("no")
```

